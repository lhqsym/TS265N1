/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: dma.proto */

#ifndef PROTOBUF_C_dma_2eproto__INCLUDED
#define PROTOBUF_C_dma_2eproto__INCLUDED

#include "protobuf-c.h"
// #include "include.h"

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003003 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _ControlEnvelope ControlEnvelope;
typedef struct _Response Response;
typedef struct _Dialog Dialog;
typedef struct _LocalAudioFile LocalAudioFile;
typedef struct _SpeechInitiator SpeechInitiator;
typedef struct _SpeechInitiator__WakeWord SpeechInitiator__WakeWord;
typedef struct _SpeechSettings SpeechSettings;
typedef struct _StartSpeech StartSpeech;
typedef struct _CallingAsrProvideSpeech CallingAsrProvideSpeech;
typedef struct _CallingAsrStopSpeech CallingAsrStopSpeech;
typedef struct _ProvideSpeech ProvideSpeech;
typedef struct _ProvideLocalAudioFile ProvideLocalAudioFile;
typedef struct _SpeechProvider SpeechProvider;
typedef struct _StopSpeech StopSpeech;
typedef struct _EndPointSpeech EndPointSpeech;
typedef struct _NotifySpeechState NotifySpeechState;
typedef struct _DualProvideSpeech DualProvideSpeech;
typedef struct _DeviceInformation DeviceInformation;
typedef struct _PairInformation PairInformation;
typedef struct _DeviceConfiguration DeviceConfiguration;
typedef struct _GetLog GetLog;
typedef struct _GetLogConfirm GetLogConfirm;
typedef struct _LogInformation LogInformation;
typedef struct _GetDeviceInformation GetDeviceInformation;
typedef struct _GetDeviceConfiguration GetDeviceConfiguration;
typedef struct _NotifyDeviceConfiguration NotifyDeviceConfiguration;
typedef struct _State State;
typedef struct _GetState GetState;
typedef struct _SetState SetState;
typedef struct _SynchronizeState SynchronizeState;
typedef struct _ForwardATCommand ForwardATCommand;
typedef struct _ForwardTestCommand ForwardTestCommand;
typedef struct _IssueMediaControl IssueMediaControl;


/* --- enums --- */

typedef enum _SpeechInitiator__Type {
    SPEECH_INITIATOR__TYPE__NONE = 0,
    SPEECH_INITIATOR__TYPE__PRESS_AND_HOLD = 1,
    SPEECH_INITIATOR__TYPE__TAP = 3,
    SPEECH_INITIATOR__TYPE__WAKEWORD = 4
                                       PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SPEECH_INITIATOR__TYPE)
} SpeechInitiator__Type;
/*
 * //////////////////////////////////////////////////////////////////////////////
 * 传输层类型。当前还不支持iAP。
 */
typedef enum _Transport {
    TRANSPORT__BLUETOOTH_LOW_ENERGY = 0,
    TRANSPORT__BLUETOOTH_RFCOMM = 1,
    TRANSPORT__BLUETOOTH_IAP = 2
                               PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSPORT)
} Transport;
/*
 * 错误代码类型。
 */
typedef enum _ErrorCode {
    ERROR_CODE__SUCCESS = 0,
    ERROR_CODE__UNKNOWN = 1,
    ERROR_CODE__INTERNAL = 2,
    ERROR_CODE__UNSUPPORTED = 3,
    ERROR_CODE__USER_CANCELLED = 4,
    ERROR_CODE__NOT_FOUND = 5,
    ERROR_CODE__INVALID = 6,
    ERROR_CODE__BUSY = 7,
    /*
     *Pair的错误返回：已经被配对了
     */
    ERROR_CODE__NOT_IN_PAIR_MODE = 8,
    /*
     *签名验证失败
     */
    ERROR_CODE__SIGN_VERIFY_FAIL = 9
                                   PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(ERROR_CODE)
} ErrorCode;
/*
 * 控制指令类型。
 */
typedef enum _Command {
    /*
     *Speech Recognition
     */
    COMMAND__PROVIDE_SPEECH = 0,
    COMMAND__PROVIDE_SPEECH_ACK = 1,
    COMMAND__START_SPEECH = 2,
    COMMAND__START_SPEECH_ACK = 3,
    COMMAND__STOP_SPEECH = 4,
    COMMAND__STOP_SPEECH_ACK = 5,
    COMMAND__END_POINT_SPEECH = 6,
    COMMAND__END_POINT_SPEECH_ACK = 7,
    COMMAND__NOTIFY_SPEECH_STATE = 8,
    COMMAND__NOTIFY_SPEECH_STATE_ACK = 9,
    COMMAND__DUALPROVIDE_SPEECH = 10,
    COMMAND__DUALPROVIDE_SPEECH_ACK = 11,
    COMMAND__PROVIDE_LOCAL_AUDIO_FILE = 12,
    COMMAND__PROVIDE_LOCAL_AUDIO_FILE_ACK = 13,
    COMMAND__CALLINGASR_PROVIDE_SPEECH = 14,
    COMMAND__CALLINGASR_PROVIDE_SPEECH_ACK = 15,
    COMMAND__CALLINGASR_STOP_SPEECH = 16,
    COMMAND__CALLINGASR_STOP_SPEECH_ACK = 17,
    /*
     *Device
     */
    COMMAND__GET_DEVICE_INFORMATION = 20,
    COMMAND__GET_DEVICE_INFORMATION_ACK = 21,
    COMMAND__GET_DEVICE_CONFIGURATION = 22,
    COMMAND__GET_DEVICE_CONFIGURATION_ACK = 23,
    COMMAND__NOTIFY_DEVICE_CONFIGURATION = 24,
    COMMAND__NOTIFY_DEVICE_CONFIGURATION_ACK = 25,
    COMMAND__PAIR = 26,
    COMMAND__PAIR_ACK = 27,
    /*
     *State
     */
    COMMAND__GET_STATE = 30,
    COMMAND__GET_STATE_ACK = 31,
    COMMAND__SET_STATE = 32,
    COMMAND__SET_STATE_ACK = 33,
    COMMAND__SYNCHRONIZE_STATE = 34,
    COMMAND__SYNCHRONIZE_STATE_ACK = 35,
    /*
     *Cellular calling
     */
    COMMAND__FORWARD_AT_COMMAND = 40,
    COMMAND__FORWARD_AT_COMMAND_ACK = 41,
    /*
     *Test command
     */
    COMMAND__FORWARD_TEST_COMMAND = 42,
    COMMAND__FORWARD_TEST_COMMAND_ACK = 43,
    /*
     *Media
     */
    COMMAND__ISSUE_MEDIA_CONTROL = 44,
    COMMAND__ISSUE_MEDIA_CONTROL_ACK = 45,
    /*
     * log
     */
    COMMAND__GET_LOG = 46,
    COMMAND__GET_LOG_ACK = 47,
    COMMAND__GET_LOG_CONFIRM = 48,
    COMMAND__GET_LOG_CONFIRM_ACK = 49
                                   PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COMMAND)
} Command;
typedef enum _AudioSource {
    AUDIO_SOURCE__STREAM = 0
                           PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(AUDIO_SOURCE)
} AudioSource;
typedef enum _AudioProfile {
    AUDIO_PROFILE__CLOSE_TALK = 0,
    AUDIO_PROFILE__NEAR_FIELD = 1,
    AUDIO_PROFILE__FAR_FIELD = 2
                               PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(AUDIO_PROFILE)
} AudioProfile;
typedef enum _AudioFormat {
    AUDIO_FORMAT__PCM_L16_16KHZ_MONO = 0,
    AUDIO_FORMAT__OPUS_16KHZ_32KBPS_CBR_0_20MS = 1,
    AUDIO_FORMAT__OPUS_16KHZ_16KBPS_CBR_0_20MS = 2,
    AUDIO_FORMAT__MSBC = 3,
    AUDIO_FORMAT__SPEEX_16KHZ_16KBPS = 4,
    AUDIO_FORMAT__SBC_16KHZ_MONO_16KBPS_28BITPOOL_16NUMBLOCKS_8SUBBANDS_SNR = 5,
    /*
     *波束算法特征值
     */
    AUDIO_FORMAT__MODEL_BEAMFORMING_ASR = 6,
    /*
     *波束算法特征值加1KBps OPUS音频
     */
    AUDIO_FORMAT__MODEL_BEAMFORMING_ASR_AND_OPUS_16KHZ_8KBPS_CBR_0_20MS = 7,
    /*
     *自定义双通道opus数据，主要用于通话转写数据传输
     */
    AUDIO_FORMAT__OPUS_16KHZ_32KBPS_CBR_0_20MS_DUAL_CHANNEL = 8
            PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(AUDIO_FORMAT)
} AudioFormat;
typedef enum _AudioScene {
    /*
     * APP里触发query的场景（点击小度头）
     */
    AUDIO_SCENE__SCENE_QUERY = 0,
    /*
     * 多轮场景
     */
    AUDIO_SCENE__SCENE_ASK_MULTI_SESSION_LISTEN = 1,
    /*
     * voice_command触发拉起APP后进行ProvideSpeech会携带此属性标明当前是自动拉起进行asr交互场景
     */
    AUDIO_SCENE__SCENE_VOICE_COMMAND = 2,
    /*
     * 翻译对话模式下APP发起的ProvideSpeech
     */
    AUDIO_SCENE__SCENE_TRANS_DIALOGUE = 3
                                        PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(AUDIO_SCENE)
} AudioScene;
typedef enum _SpeechState {
    SPEECH_STATE__IDLE = 0,
    SPEECH_STATE__LISTENING = 1,
    SPEECH_STATE__PROCESSING = 2,
    SPEECH_STATE__SPEAKING = 3
                             PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SPEECH_STATE)
} SpeechState;
typedef enum _InitiatorType {
    /*
     *可选的值："PRESS_AND_HOLD", "TAP", "PHONE_WAKEUP"
     */
    INITIATOR_TYPE__PRESS_AND_HOLD = 0,
    INITIATOR_TYPE__TAP = 1,
    INITIATOR_TYPE__PHONE_WAKEUP = 2,
    INITIATOR_TYPE__WAIT_FOLLOW_WAKEUP = 3
                                         PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(INITIATOR_TYPE)
} InitiatorType;
typedef enum _SignMethod {
    SIGN_METHOD__SHA256 = 0,
    SIGN_METHOD__SHA1 = 1,
    /*
     *不建议使用
     */
    SIGN_METHOD__MD5SUM = 2
                          PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SIGN_METHOD)
} SignMethod;
typedef enum _MediaControl {
    MEDIA_CONTROL__PLAY = 0,
    MEDIA_CONTROL__PAUSE = 1,
    MEDIA_CONTROL__NEXT = 2,
    MEDIA_CONTROL__PREVIOUS = 3,
    MEDIA_CONTROL__ABSOLUTE_VOLUME = 4
                                     PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(MEDIA_CONTROL)
} MediaControl;

/* --- messages --- */

typedef enum {
    CONTROL_ENVELOPE__PAYLOAD__NOT_SET = 0,
    CONTROL_ENVELOPE__PAYLOAD_RESPONSE = 9,
    CONTROL_ENVELOPE__PAYLOAD_PROVIDE_SPEECH = 21,
    CONTROL_ENVELOPE__PAYLOAD_START_SPEECH = 22,
    CONTROL_ENVELOPE__PAYLOAD_STOP_SPEECH = 23,
    CONTROL_ENVELOPE__PAYLOAD_END_POINT_SPEECH = 24,
    CONTROL_ENVELOPE__PAYLOAD_NOTIFY_SPEECH_STATE = 25,
    CONTROL_ENVELOPE__PAYLOAD_GET_DEVICE_INFORMATION = 26,
    CONTROL_ENVELOPE__PAYLOAD_GET_DEVICE_CONFIGURATION = 27,
    CONTROL_ENVELOPE__PAYLOAD_NOTIFY_DEVICE_CONFIGURATION = 28,
    CONTROL_ENVELOPE__PAYLOAD_GET_STATE = 29,
    CONTROL_ENVELOPE__PAYLOAD_SET_STATE = 30,
    CONTROL_ENVELOPE__PAYLOAD_SYNCHRONIZE_STATE = 31,
    CONTROL_ENVELOPE__PAYLOAD_FORWARD_ATCOMMAND = 32,
    CONTROL_ENVELOPE__PAYLOAD_FORWARD_TEST_COMMAND = 33,
    CONTROL_ENVELOPE__PAYLOAD_ISSUE_MEDIA_CONTROL = 34,
    CONTROL_ENVELOPE__PAYLOAD_DUAL_PROVIDE_SPEECH = 35,
    CONTROL_ENVELOPE__PAYLOAD_PROVIDE_LOCAL_AUDIO_FILE = 36,
    CONTROL_ENVELOPE__PAYLOAD_GET_LOG = 37,
    CONTROL_ENVELOPE__PAYLOAD_GET_LOG_CONFIRM = 38,
    CONTROL_ENVELOPE__PAYLOAD_CALLING_PROVIDE_SPEECH = 39,
    CONTROL_ENVELOPE__PAYLOAD_CALLING_STOP_SPEECH = 40
            PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CONTROL_ENVELOPE__PAYLOAD)
} ControlEnvelope__PayloadCase;

/*
 * //////////////////////////////////////////////////////////////////////////////
 * 控制指令封装
 * 每一个发送到控制流的信息都需要被包在ControlEnvelope里面。详细定义如下。
 */
struct  _ControlEnvelope {
    ProtobufCMessage base;
    Command command;
    /*
     *主动发起的command，带上这个参数，Ack的command会照原样带回来，建议长度不超过6个字节
     */
    char* request_id;
    /*
     *sign2与rand2皆为可选字段，用于手机发起的指令的签名，在外设对此字段做相应的鉴权操作，具体清空README.md中关于鉴权的描述
     *目前仅有PROVIDE_SPEECH和GET_STATE(ENTER_OTA_MODE)需要带sign2字段
     *sign2 = sha256(rand2 + rand + key + product\_id + serial\_number)
     *签名算法需要使用PairInformation中的SignMethod
     *起名sign2和rand2是为了区分PairInformation中的sign和rand
     */
    char* sign2;
    /*
     *可选
     */
    char* rand2;
    ControlEnvelope__PayloadCase payload_case;
    union {
        Response* response;
        /*
         *command messages
         */
        ProvideSpeech* providespeech;
        StartSpeech* startspeech;
        StopSpeech* stopspeech;
        EndPointSpeech* endpointspeech;
        NotifySpeechState* notifyspeechstate;
        GetDeviceInformation* getdeviceinformation;
        GetDeviceConfiguration* getdeviceconfiguration;
        NotifyDeviceConfiguration* notifydeviceconfiguration;
        GetState* getstate;
        SetState* setstate;
        SynchronizeState* synchronizestate;
        ForwardATCommand* forwardatcommand;
        ForwardTestCommand* forwardtestcommand;
        /*
         *Media, mapping avrcp
         */
        IssueMediaControl* issue_media_control;
        /*
         *用于支持两路录音模式下的central（手机）向perphiral（比如耳机）发起录音请求，perphiral收到该命令后在上行数据中需要告知central两路录音数据的区分
         */
        DualProvideSpeech* dualprovidespeech;
        /*
         *用于设备端灌测，APP端告知设备端传哪个音频文件
         */
        ProvideLocalAudioFile* providelocalaudiofile;
        GetLog* getlog;
        GetLogConfirm* getlogconfirm;
        /*
         *进行通话转写时由app发送给固件端，告知app里开始通话转写了，固件端会发送语音通话的数据流，该数据流由自己的语音数据包和对方的语音数据包组成
         */
        CallingAsrProvideSpeech* callingprovidespeech;
        /*
         *进行通话转写时由app发送给固件端，告知结束通话转写，停止传流
         */
        CallingAsrStopSpeech* callingstopspeech;
    };
};
#define CONTROL_ENVELOPE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&control_envelope__descriptor) \
    , COMMAND__PROVIDE_SPEECH, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, CONTROL_ENVELOPE__PAYLOAD__NOT_SET, {0} }


typedef enum {
    RESPONSE__PAYLOAD__NOT_SET = 0,
    RESPONSE__PAYLOAD_SPEECH_PROVIDER = 11,
    RESPONSE__PAYLOAD_DEVICE_INFORMATION = 12,
    RESPONSE__PAYLOAD_DEVICE_CONFIGURATION = 13,
    RESPONSE__PAYLOAD_STATE = 14,
    RESPONSE__PAYLOAD_PAIR_INFORMATION = 15,
    RESPONSE__PAYLOAD_LOG_INFORMATION = 16
                                        PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(RESPONSE__PAYLOAD)
} Response__PayloadCase;

/*
 * 每一个发送到控制流的控制指令都需要有一个回复（ACK）。
 */
struct  _Response {
    ProtobufCMessage base;
    ErrorCode error_code;
    Response__PayloadCase payload_case;
    union {
        SpeechProvider* speechprovider;
        DeviceInformation* deviceinformation;
        DeviceConfiguration* deviceconfiguration;
        State* state;
        PairInformation* pairinformation;
        LogInformation* loginformation;
    };
};
#define RESPONSE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&response__descriptor) \
    , ERROR_CODE__SUCCESS, RESPONSE__PAYLOAD__NOT_SET, {0} }


/*
 * //////////////////////////////////////////////////////////////////////////////
 * 能力：语音识别
 */
struct  _Dialog {
    ProtobufCMessage base;
    uint32_t id;
};
#define DIALOG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dialog__descriptor) \
    , 0 }


struct  _LocalAudioFile {
    ProtobufCMessage base;
    uint32_t id;
    uint32_t record_channel_num;
};
#define LOCAL_AUDIO_FILE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&local_audio_file__descriptor) \
    , 0, 0 }


struct  _SpeechInitiator__WakeWord {
    ProtobufCMessage base;
    uint32_t start_index_in_samples;
    uint32_t end_index_in_samples;
};
#define SPEECH_INITIATOR__WAKE_WORD__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_initiator__wake_word__descriptor) \
    , 0, 0 }


struct  _SpeechInitiator {
    ProtobufCMessage base;
    SpeechInitiator__Type type;
    SpeechInitiator__WakeWord* wake_word;
    /*
     *控制手机端是否播放唤醒提示音
     */
    protobuf_c_boolean play_prompt_tone;
    /*
     * 出入耳状态，1_1:左右都入 1_0:左耳入、右耳未入 0_1:左耳未入、右耳入 0_0:左右耳都未入
     */
    char* in_out_ear;
};
#define SPEECH_INITIATOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_initiator__descriptor) \
    , SPEECH_INITIATOR__TYPE__NONE, NULL, 0, (char *)protobuf_c_empty_string }


struct  _SpeechSettings {
    ProtobufCMessage base;
    AudioProfile audio_profile;
    AudioFormat audio_format;
    AudioSource audio_source;
    /*
     * 可选；主要用于ProvideSpeech，用于区分APP里某些业务场景下query的区分和适配
     */
    AudioScene audio_scene;
};
#define SPEECH_SETTINGS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_settings__descriptor) \
    , AUDIO_PROFILE__CLOSE_TALK, AUDIO_FORMAT__PCM_L16_16KHZ_MONO, AUDIO_SOURCE__STREAM, AUDIO_SCENE__SCENE_QUERY }


struct  _StartSpeech {
    ProtobufCMessage base;
    SpeechSettings* settings;
    SpeechInitiator* initiator;
    Dialog* dialog;
};
#define START_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&start_speech__descriptor) \
    , NULL, NULL, NULL }


struct  _CallingAsrProvideSpeech {
    ProtobufCMessage base;
    SpeechSettings* settings;
    Dialog* dialog;
};
#define CALLING_ASR_PROVIDE_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&calling_asr_provide_speech__descriptor) \
    , NULL, NULL }


struct  _CallingAsrStopSpeech {
    ProtobufCMessage base;
    ErrorCode error_code;
    Dialog* dialog;
};
#define CALLING_ASR_STOP_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&calling_asr_stop_speech__descriptor) \
    , ERROR_CODE__SUCCESS, NULL }


struct  _ProvideSpeech {
    ProtobufCMessage base;
    Dialog* dialog;
    SpeechSettings* settings;
};
#define PROVIDE_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&provide_speech__descriptor) \
    , NULL, NULL }


struct  _ProvideLocalAudioFile {
    ProtobufCMessage base;
    Dialog* dialog;
    LocalAudioFile* local_audio_file;
    SpeechSettings* settings;
};
#define PROVIDE_LOCAL_AUDIO_FILE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&provide_local_audio_file__descriptor) \
    , NULL, NULL, NULL }


struct  _SpeechProvider {
    ProtobufCMessage base;
    SpeechSettings* settings;
    Dialog* dialog;
};
#define SPEECH_PROVIDER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_provider__descriptor) \
    , NULL, NULL }


struct  _StopSpeech {
    ProtobufCMessage base;
    ErrorCode error_code;
    Dialog* dialog;
};
#define STOP_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&stop_speech__descriptor) \
    , ERROR_CODE__SUCCESS, NULL }


struct  _EndPointSpeech {
    ProtobufCMessage base;
    Dialog* dialog;
};
#define END_POINT_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&end_point_speech__descriptor) \
    , NULL }


struct  _NotifySpeechState {
    ProtobufCMessage base;
    SpeechState state;
};
#define NOTIFY_SPEECH_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&notify_speech_state__descriptor) \
    , SPEECH_STATE__IDLE }


struct  _DualProvideSpeech {
    ProtobufCMessage base;
    Dialog* dialog;
    SpeechSettings* settings;
};
#define DUAL_PROVIDE_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dual_provide_speech__descriptor) \
    , NULL, NULL }


/*
 * //////////////////////////////////////////////////////////////////////////////
 * 能力：设备信息
 */
struct  _DeviceInformation {
    ProtobufCMessage base;
    char* serial_number;
    char* name;
    size_t n_supported_transports;
    Transport* supported_transports;
    /*
     *default "3P" //HEADPHONE, SPEAKER, DOCK, TWS_HEADSET 新增TWS耳机类型
     */
    char* device_type;
    size_t n_supported_audio_formats;
    AudioFormat* supported_audio_formats;
    /*
     *厂商
     */
    char* manufacturer;
    /*
     *型号
     */
    char* model;
    /*
     *string software_version=9; // 已废弃
     */
    char* firmware_version;
    /*
     *设备支持的语音交互方式
     */
    InitiatorType initiator_type;
    /*
     *产品id需要从度秘平台获得, 为空的时候，判定设备为UNKONWN或者OTHER。 长度不超过32字节
     */
    char* product_id;
    /*
     *类似06:36:3b:cd:c1:b0
     */
    char* classic_bluetooth_mac;
    /*
     *移动到了PairInformation，为了不引起兼容问题，以下13、14不要再使用了
     *string rand=13;//长度8位的随机字符串。注意：需要每次返回都不一样。具体逻辑请看README.md中的鉴权部分
     *string sign=14;//sign = sha256(rand + key + product_id + serial_number),  key需要从度秘平台获得。具体逻辑请看README.md中的鉴权部分
     */
    /*
     *如果这个字段为false，手机端会每1-2秒发一个GET_STATE的请求，作为设备的心跳包。设为true的时候，手机不发送心跳请求
     */
    protobuf_c_boolean disable_heart_beat;
    /*
     *如果这个字段为true，手机端生成sign2的时候会做第二次hash, new_sign2 = sign_method ( sign2 + requestId + int2string(command))，具体逻辑请看README.md中的“高级安全”部分
     */
    protobuf_c_boolean enable_advanced_security;
    /*
     *可选，默认为false；标识设备是否使用FM发射的方式播放音频。如果这个字段为true。app连接外设成功之后会触发fm发射频率设置的逻辑。
     */
    protobuf_c_boolean support_fm;
    /*
     *string ota_version=18;//(已废弃)可选，标识外设上负责ota软件的版本。ota的软件和实现功能的软件（software_version）是独立的，所以版本号也独立
     */
    /*
     *如果这个字段为true，手机端不再强制要求当前a2dp输出的设备，和dma设备是同一个设备
     */
    protobuf_c_boolean no_a2dp;
    /*
     *如果这个字段为true，设备不支持DMA的ForwardATCommand指令，这样小度app在尝试帮用户拨打电话的时候，不会使用ForwardATCommand，而是使用ios或安卓系统的拨号api
     */
    protobuf_c_boolean no_at_command;
    /*
     *如果这个字段为true，设备支持DMA的Media能力。这样小度app在执行音量调整的时候，会发送IssueMediaControl指令。在小度app收到用户的“下一首”之类的query的时候，如果当前没有媒体播放，会尝试用IssueMediaControl指令控制手机上的其它播放器。
     */
    protobuf_c_boolean support_media;
    /*
     *如果这个字段为true，设备支持DMA的静默升级能力
     */
    protobuf_c_boolean support_sota;
    /*
     *是否是耳机类产品，默认为false
     */
    protobuf_c_boolean is_earphone;
    /*
     *是否支持双路录音模式，一般指两个Mic的产品，比如耳机类产品;(已废弃)
     */
    protobuf_c_boolean support_dual_record;
    /*
     *是否支持设备端本地唤醒， 缺省值false
     */
    protobuf_c_boolean support_local_voice_wake;
    /*
     *是否支持本地文件灌测
     */
    protobuf_c_boolean support_local_audio_file;
    /*
     *是否支持波束算法特征值
     */
    protobuf_c_boolean support_model_beamforming_asr;
    /*
     * 是否支持云端映射serial_number
     */
    protobuf_c_boolean support_mapping_serial_number;
    /*
     * 目前仅限tws耳机使用，云端映射serial_number
     */
    char* mapping_serial_number;
    /*
     * 目前仅限tws耳机使用，tws耳机左右耳serial_number不同，serial_number标识左耳耳机，serial_number1标识右耳耳机
     */
    char* serial_number1;
    /*
     * 目前仅限tws耳机使用，tws耳机左右耳mac地址不同，classic_bluetooth_mac标识左耳的mac，classic_bluetooth_mac1标识右耳的mac
     */
    char* classic_bluetooth_mac1;
    /*
     * 可选，蓝牙外设是否支持打点，字段存在且值为true支持打点，其他情况不支持
     */
    protobuf_c_boolean support_log;
    /*
     * 是否支持"下一首"唤醒词
     */
    protobuf_c_boolean support_wakeword_next;
    /*
     * 支持的电量结构，0：不支持电量展示，2：仅支持双耳电量展示，3：支持双耳电量+盒仓电量，4：单体设备电量（如小度蓝牙音箱）；该属性缺省值是0
     */
    uint64_t battery_structure;
    /*
     * 是否支持自定义触控，0：不支持，1：小度一代tws耳机风格，2：小度二代pro耳机风格，3：小度C版耳机风格
     */
    uint64_t touch_setting_type;
    /*
     *是否支持ANC主动降噪, 缺省值false
     */
    protobuf_c_boolean support_anc;
    /*
     * 是否支持耳塞贴合度检测，缺省值false
     */
    protobuf_c_boolean support_fit_detection;
    /*
     * 是否支持耳机入耳检测，缺省值false
     */
    protobuf_c_boolean support_in_ear_detection;
    /*
     * 是否支持查找耳机功能，缺失值false
     */
    protobuf_c_boolean support_find_earphone;
    /*
     * 固件根据三元组+固件指纹生成，云端对固件鉴权使用, 不需要三元组鉴权的设备可选。
     */
    char* token;
    /*
     * 三元组之一
     */
    char* triad_id;
    /*
     * 是否支持"声音大一点"唤醒词
     */
    protobuf_c_boolean support_wakeword_volumeup;
    /*
     * 是否支持"声音小一点"唤醒词
     */
    protobuf_c_boolean support_wakeword_volumedown;
    /*
     * 是否支持GATT Over BR/EDR 经典蓝牙
     */
    protobuf_c_boolean support_gatt_over_br_edr;
    /*
     *是否支持游戏模式，缺省值false
     */
    protobuf_c_boolean support_game_mode;
    /*
     *是否支持关盖电量提醒
     */
    protobuf_c_boolean support_battery_reminder;
};
#define DEVICE_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&device_information__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0,NULL, (char *)protobuf_c_empty_string, 0,NULL, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, INITIATOR_TYPE__PRESS_AND_HOLD, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0, 0, 0, 0, 0, 0, 0, 0, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0, 0, 0, 0, 0 }


struct  _PairInformation {
    ProtobufCMessage base;
    /*
     *长度8位的随机字符串。注意：需要每次返回都不一样，一旦返回后，需要把这个值保存下来，供ProvideSpeech的签名验证使用。具体逻辑请看README.md中的鉴权部分
     */
    char* rand;
    /*
     *sign = sha256(rand + key + product_id + serial_number),  key需要从度秘平台获得。具体逻辑请看README.md中的鉴权部分
     */
    char* sign;
    /*
     *签名算法
     */
    SignMethod signmethod;
};
#define PAIR_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&pair_information__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, SIGN_METHOD__SHA256 }


struct  _DeviceConfiguration {
    ProtobufCMessage base;
    /*
     *现在都是false，不需要
     */
    protobuf_c_boolean needs_assistant_override;
    protobuf_c_boolean needs_setup;
    /*
     * 表示固件是否支持设置静音
     */
    protobuf_c_boolean support_mute;
    /*
     * 健康提醒，0: 不支持该功能; 1: 提醒; 2: 不提醒;
     */
    uint32_t health_reminder;
    /*
     *支持风噪检测
     */
    protobuf_c_boolean support_wind_noise_detection;
    /*
     * 表示固件是否支持个性化音效定制
     */
    protobuf_c_boolean support_sound_effects;
    /*
     * 表示固件是否支持来电长按拒接配置
     */
    protobuf_c_boolean support_call_reject_config;
    /*
     * 是否支持双路录音模式，一般指两个Mic的产品，比如耳机类产品
     */
    protobuf_c_boolean support_dual_record;
    /*
     * 是否支持听力保护功能，目前开启后主要用于耳机端最大音量限制
     */
    protobuf_c_boolean support_hearing_protection;
    /*
     *可支持替换音频的数量，默认为0表示不支持音频替换功能。
     */
    uint32_t replace_local_speech_count;
};
#define DEVICE_CONFIGURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&device_configuration__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }


struct  _GetLog {
    ProtobufCMessage base;
    uint64_t get_log_time;
};
#define GET_LOG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_log__descriptor) \
    , 0 }


struct  _GetLogConfirm {
    ProtobufCMessage base;
};
#define GET_LOG_CONFIRM__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_log_confirm__descriptor) \
     }


/*
 * 能力：日志信息
 */
struct  _LogInformation {
    ProtobufCMessage base;
    char* serial_number;
    char* firmware_version;
    /*
     * 起始时间,毫秒级时间戳
     */
    uint64_t start_time;
    /*
     * 终止时间,毫秒级时间戳
     */
    uint64_t end_time;
    /*
     * 语音唤醒次数
     */
    uint32_t voice_wakeup_times;
    /*
     * 敲击唤醒次数
     */
    uint32_t tap_wakeup_times;
    /*
     * 唤醒时dma处于连接次数
     */
    uint32_t wakeup_dma_connected_times;
    /*
     * 唤醒是dma处于断连次数
     */
    uint32_t wakeup_dma_disconnected_times;
    /*
     * 发起StartSpeech次数
     */
    uint32_t start_speech_times;
    /*
     * 收到StartSpeechACK次数
     */
    uint32_t start_speech_ack_times;
    /*
     * 收到ProvideSpeech发起StartSpeech次数
     */
    uint32_t provide_start_speech_times;
    /*
     * 左耳播放卡顿次数
     */
    uint32_t left_a2dp_mute_times;
    /*
     * 右耳播放卡顿次数
     */
    uint32_t right_a2dp_mute_times;
    /*
     * 左耳上行阻塞次数
     */
    uint32_t left_a2dp_block_times;
    /*
     * 右耳上行阻塞次数
     */
    uint32_t right_a2dp_block_times;
    /*
     * 左耳A2DP下CPU过载次数
     */
    uint32_t left_a2dp_cpu_overload_times;
    /*
     * 右耳HFP下CPU过载次数
     */
    uint32_t right_a2dp_cpu_overload_times;
    /*
     * 左耳A2DP下CPU过载次数
     */
    uint32_t left_hfp_cpu_overload_times;
    /*
     * 右耳HFP下CPU过载次数
     */
    uint32_t right_hfp_cpu_overload_times;
    /*
     * 左耳TTS吞字次数
     */
    uint32_t left_a2dp_tts_drop_times;
    /*
     * 右耳TTS吞字次数
     */
    uint32_t right_a2dp_tts_drop_times;
    /*
     * 播放唤醒在呢TTS成功次数
     */
    uint32_t wakeup_tts_succeeded_times;
    /*
     * 播放唤醒在呢TTS失败次数
     */
    uint32_t wakeup_tts_failed_times;
    /*
     * 播放"正在连接小度"TTS成功次数
     */
    uint32_t launch_app_tts_succeeded_times;
    /*
     * 播放"正在连接小度"TTS失败次数
     */
    uint32_t launch_app_tts_failed_times;
    /*
     * 左耳通话中SCO链路被断开
     */
    uint32_t left_hfp_sco_disconnect_times;
    /*
     * 右耳通话中SCO链路被断开
     */
    uint32_t right_hfp_sco_disconnect_times;
    /*
     * 左耳开机时长
     */
    uint32_t left_working_time;
    /*
     * 右耳开机时长
     */
    uint32_t right_working_time;
    /*
     * 左耳出仓时长
     */
    uint32_t left_outside_time;
    /*
     * 右耳出仓时长
     */
    uint32_t right_outside_time;
    /*
     * 左耳入耳时长
     */
    uint32_t left_wearing_on_time;
    /*
     * 右耳入耳时长
     */
    uint32_t right_wearing_on_time;
    /*
     * 左耳播放音乐时长
     */
    uint32_t left_playing_music_time;
    /*
     * 右耳播放音乐时长
     */
    uint32_t right_playing_music_time;
    /*
     * 左耳通话时长
     */
    uint32_t left_talking_time;
    /*
     * 右耳通话时长
     */
    uint32_t right_talking_time;
    /*
     * 左耳连接DMA时长
     */
    uint32_t left_dma_connected_time;
    /*
     * 右耳连接DMA时长
     */
    uint32_t right_dma_connected_time;
};
#define LOG_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&log_information__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }


struct  _GetDeviceInformation {
    ProtobufCMessage base;
};
#define GET_DEVICE_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_device_information__descriptor) \
     }


struct  _GetDeviceConfiguration {
    ProtobufCMessage base;
};
#define GET_DEVICE_CONFIGURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_device_configuration__descriptor) \
     }


struct  _NotifyDeviceConfiguration {
    ProtobufCMessage base;
};
#define NOTIFY_DEVICE_CONFIGURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&notify_device_configuration__descriptor) \
     }


typedef enum {
    STATE__VALUE__NOT_SET = 0,
    STATE__VALUE_BOOLEAN = 2,
    STATE__VALUE_INTEGER = 3,
    STATE__VALUE_STR = 4
                       PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(STATE__VALUE)
} State__ValueCase;

struct  _State {
    ProtobufCMessage base;
    uint32_t feature;
    /*
     * 新增扩展string字段
     */
    char* ext;
    State__ValueCase value_case;
    union {
        protobuf_c_boolean boolean;
        uint32_t integer;
        char* str;
    };
};
#define STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&state__descriptor) \
    , 0, (char *)protobuf_c_empty_string, STATE__VALUE__NOT_SET, {0} }


struct  _GetState {
    ProtobufCMessage base;
    uint32_t feature;
};
#define GET_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_state__descriptor) \
    , 0 }


struct  _SetState {
    ProtobufCMessage base;
    State* state;
};
#define SET_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&set_state__descriptor) \
    , NULL }


struct  _SynchronizeState {
    ProtobufCMessage base;
    State* state;
};
#define SYNCHRONIZE_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&synchronize_state__descriptor) \
    , NULL }


struct  _ForwardATCommand {
    ProtobufCMessage base;
    char* command;
};
#define FORWARD_ATCOMMAND__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&forward_atcommand__descriptor) \
    , (char *)protobuf_c_empty_string }


struct  _ForwardTestCommand {
    ProtobufCMessage base;
    char* command;
};
#define FORWARD_TEST_COMMAND__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&forward_test_command__descriptor) \
    , (char *)protobuf_c_empty_string }


struct  _IssueMediaControl {
    ProtobufCMessage base;
    MediaControl control;
    /*
     *0-100, 只有control == ABSOLUTE_VOLUME的时候生效。
     */
    uint32_t volume;
};
#define ISSUE_MEDIA_CONTROL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&issue_media_control__descriptor) \
    , MEDIA_CONTROL__PLAY, 0 }


/* ControlEnvelope methods */
void   control_envelope__init
(ControlEnvelope*         message);
size_t control_envelope__get_packed_size
(const ControlEnvelope*   message);
size_t control_envelope__pack
(const ControlEnvelope*   message,
 uint8_t*             out);
size_t control_envelope__pack_to_buffer
(const ControlEnvelope*   message,
 ProtobufCBuffer*     buffer);
ControlEnvelope*
control_envelope__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   control_envelope__free_unpacked
(ControlEnvelope* message,
 ProtobufCAllocator* allocator);
/* Response methods */
void   response__init
(Response*         message);
size_t response__get_packed_size
(const Response*   message);
size_t response__pack
(const Response*   message,
 uint8_t*             out);
size_t response__pack_to_buffer
(const Response*   message,
 ProtobufCBuffer*     buffer);
Response*
response__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   response__free_unpacked
(Response* message,
 ProtobufCAllocator* allocator);
/* Dialog methods */
void   dialog__init
(Dialog*         message);
size_t dialog__get_packed_size
(const Dialog*   message);
size_t dialog__pack
(const Dialog*   message,
 uint8_t*             out);
size_t dialog__pack_to_buffer
(const Dialog*   message,
 ProtobufCBuffer*     buffer);
Dialog*
dialog__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   dialog__free_unpacked
(Dialog* message,
 ProtobufCAllocator* allocator);
/* LocalAudioFile methods */
void   local_audio_file__init
(LocalAudioFile*         message);
size_t local_audio_file__get_packed_size
(const LocalAudioFile*   message);
size_t local_audio_file__pack
(const LocalAudioFile*   message,
 uint8_t*             out);
size_t local_audio_file__pack_to_buffer
(const LocalAudioFile*   message,
 ProtobufCBuffer*     buffer);
LocalAudioFile*
local_audio_file__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   local_audio_file__free_unpacked
(LocalAudioFile* message,
 ProtobufCAllocator* allocator);
/* SpeechInitiator__WakeWord methods */
void   speech_initiator__wake_word__init
(SpeechInitiator__WakeWord*         message);
/* SpeechInitiator methods */
void   speech_initiator__init
(SpeechInitiator*         message);
size_t speech_initiator__get_packed_size
(const SpeechInitiator*   message);
size_t speech_initiator__pack
(const SpeechInitiator*   message,
 uint8_t*             out);
size_t speech_initiator__pack_to_buffer
(const SpeechInitiator*   message,
 ProtobufCBuffer*     buffer);
SpeechInitiator*
speech_initiator__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   speech_initiator__free_unpacked
(SpeechInitiator* message,
 ProtobufCAllocator* allocator);
/* SpeechSettings methods */
void   speech_settings__init
(SpeechSettings*         message);
size_t speech_settings__get_packed_size
(const SpeechSettings*   message);
size_t speech_settings__pack
(const SpeechSettings*   message,
 uint8_t*             out);
size_t speech_settings__pack_to_buffer
(const SpeechSettings*   message,
 ProtobufCBuffer*     buffer);
SpeechSettings*
speech_settings__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   speech_settings__free_unpacked
(SpeechSettings* message,
 ProtobufCAllocator* allocator);
/* StartSpeech methods */
void   start_speech__init
(StartSpeech*         message);
size_t start_speech__get_packed_size
(const StartSpeech*   message);
size_t start_speech__pack
(const StartSpeech*   message,
 uint8_t*             out);
size_t start_speech__pack_to_buffer
(const StartSpeech*   message,
 ProtobufCBuffer*     buffer);
StartSpeech*
start_speech__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   start_speech__free_unpacked
(StartSpeech* message,
 ProtobufCAllocator* allocator);
/* CallingAsrProvideSpeech methods */
void   calling_asr_provide_speech__init
(CallingAsrProvideSpeech*         message);
size_t calling_asr_provide_speech__get_packed_size
(const CallingAsrProvideSpeech*   message);
size_t calling_asr_provide_speech__pack
(const CallingAsrProvideSpeech*   message,
 uint8_t*             out);
size_t calling_asr_provide_speech__pack_to_buffer
(const CallingAsrProvideSpeech*   message,
 ProtobufCBuffer*     buffer);
CallingAsrProvideSpeech*
calling_asr_provide_speech__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   calling_asr_provide_speech__free_unpacked
(CallingAsrProvideSpeech* message,
 ProtobufCAllocator* allocator);
/* CallingAsrStopSpeech methods */
void   calling_asr_stop_speech__init
(CallingAsrStopSpeech*         message);
size_t calling_asr_stop_speech__get_packed_size
(const CallingAsrStopSpeech*   message);
size_t calling_asr_stop_speech__pack
(const CallingAsrStopSpeech*   message,
 uint8_t*             out);
size_t calling_asr_stop_speech__pack_to_buffer
(const CallingAsrStopSpeech*   message,
 ProtobufCBuffer*     buffer);
CallingAsrStopSpeech*
calling_asr_stop_speech__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   calling_asr_stop_speech__free_unpacked
(CallingAsrStopSpeech* message,
 ProtobufCAllocator* allocator);
/* ProvideSpeech methods */
void   provide_speech__init
(ProvideSpeech*         message);
size_t provide_speech__get_packed_size
(const ProvideSpeech*   message);
size_t provide_speech__pack
(const ProvideSpeech*   message,
 uint8_t*             out);
size_t provide_speech__pack_to_buffer
(const ProvideSpeech*   message,
 ProtobufCBuffer*     buffer);
ProvideSpeech*
provide_speech__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   provide_speech__free_unpacked
(ProvideSpeech* message,
 ProtobufCAllocator* allocator);
/* ProvideLocalAudioFile methods */
void   provide_local_audio_file__init
(ProvideLocalAudioFile*         message);
size_t provide_local_audio_file__get_packed_size
(const ProvideLocalAudioFile*   message);
size_t provide_local_audio_file__pack
(const ProvideLocalAudioFile*   message,
 uint8_t*             out);
size_t provide_local_audio_file__pack_to_buffer
(const ProvideLocalAudioFile*   message,
 ProtobufCBuffer*     buffer);
ProvideLocalAudioFile*
provide_local_audio_file__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   provide_local_audio_file__free_unpacked
(ProvideLocalAudioFile* message,
 ProtobufCAllocator* allocator);
/* SpeechProvider methods */
void   speech_provider__init
(SpeechProvider*         message);
size_t speech_provider__get_packed_size
(const SpeechProvider*   message);
size_t speech_provider__pack
(const SpeechProvider*   message,
 uint8_t*             out);
size_t speech_provider__pack_to_buffer
(const SpeechProvider*   message,
 ProtobufCBuffer*     buffer);
SpeechProvider*
speech_provider__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   speech_provider__free_unpacked
(SpeechProvider* message,
 ProtobufCAllocator* allocator);
/* StopSpeech methods */
void   stop_speech__init
(StopSpeech*         message);
size_t stop_speech__get_packed_size
(const StopSpeech*   message);
size_t stop_speech__pack
(const StopSpeech*   message,
 uint8_t*             out);
size_t stop_speech__pack_to_buffer
(const StopSpeech*   message,
 ProtobufCBuffer*     buffer);
StopSpeech*
stop_speech__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   stop_speech__free_unpacked
(StopSpeech* message,
 ProtobufCAllocator* allocator);
/* EndPointSpeech methods */
void   end_point_speech__init
(EndPointSpeech*         message);
size_t end_point_speech__get_packed_size
(const EndPointSpeech*   message);
size_t end_point_speech__pack
(const EndPointSpeech*   message,
 uint8_t*             out);
size_t end_point_speech__pack_to_buffer
(const EndPointSpeech*   message,
 ProtobufCBuffer*     buffer);
EndPointSpeech*
end_point_speech__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   end_point_speech__free_unpacked
(EndPointSpeech* message,
 ProtobufCAllocator* allocator);
/* NotifySpeechState methods */
void   notify_speech_state__init
(NotifySpeechState*         message);
size_t notify_speech_state__get_packed_size
(const NotifySpeechState*   message);
size_t notify_speech_state__pack
(const NotifySpeechState*   message,
 uint8_t*             out);
size_t notify_speech_state__pack_to_buffer
(const NotifySpeechState*   message,
 ProtobufCBuffer*     buffer);
NotifySpeechState*
notify_speech_state__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   notify_speech_state__free_unpacked
(NotifySpeechState* message,
 ProtobufCAllocator* allocator);
/* DualProvideSpeech methods */
void   dual_provide_speech__init
(DualProvideSpeech*         message);
size_t dual_provide_speech__get_packed_size
(const DualProvideSpeech*   message);
size_t dual_provide_speech__pack
(const DualProvideSpeech*   message,
 uint8_t*             out);
size_t dual_provide_speech__pack_to_buffer
(const DualProvideSpeech*   message,
 ProtobufCBuffer*     buffer);
DualProvideSpeech*
dual_provide_speech__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   dual_provide_speech__free_unpacked
(DualProvideSpeech* message,
 ProtobufCAllocator* allocator);
/* DeviceInformation methods */
void   device_information__init
(DeviceInformation*         message);
size_t device_information__get_packed_size
(const DeviceInformation*   message);
size_t device_information__pack
(const DeviceInformation*   message,
 uint8_t*             out);
size_t device_information__pack_to_buffer
(const DeviceInformation*   message,
 ProtobufCBuffer*     buffer);
DeviceInformation*
device_information__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   device_information__free_unpacked
(DeviceInformation* message,
 ProtobufCAllocator* allocator);
/* PairInformation methods */
void   pair_information__init
(PairInformation*         message);
size_t pair_information__get_packed_size
(const PairInformation*   message);
size_t pair_information__pack
(const PairInformation*   message,
 uint8_t*             out);
size_t pair_information__pack_to_buffer
(const PairInformation*   message,
 ProtobufCBuffer*     buffer);
PairInformation*
pair_information__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   pair_information__free_unpacked
(PairInformation* message,
 ProtobufCAllocator* allocator);
/* DeviceConfiguration methods */
void   device_configuration__init
(DeviceConfiguration*         message);
size_t device_configuration__get_packed_size
(const DeviceConfiguration*   message);
size_t device_configuration__pack
(const DeviceConfiguration*   message,
 uint8_t*             out);
size_t device_configuration__pack_to_buffer
(const DeviceConfiguration*   message,
 ProtobufCBuffer*     buffer);
DeviceConfiguration*
device_configuration__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   device_configuration__free_unpacked
(DeviceConfiguration* message,
 ProtobufCAllocator* allocator);
/* GetLog methods */
void   get_log__init
(GetLog*         message);
size_t get_log__get_packed_size
(const GetLog*   message);
size_t get_log__pack
(const GetLog*   message,
 uint8_t*             out);
size_t get_log__pack_to_buffer
(const GetLog*   message,
 ProtobufCBuffer*     buffer);
GetLog*
get_log__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   get_log__free_unpacked
(GetLog* message,
 ProtobufCAllocator* allocator);
/* GetLogConfirm methods */
void   get_log_confirm__init
(GetLogConfirm*         message);
size_t get_log_confirm__get_packed_size
(const GetLogConfirm*   message);
size_t get_log_confirm__pack
(const GetLogConfirm*   message,
 uint8_t*             out);
size_t get_log_confirm__pack_to_buffer
(const GetLogConfirm*   message,
 ProtobufCBuffer*     buffer);
GetLogConfirm*
get_log_confirm__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   get_log_confirm__free_unpacked
(GetLogConfirm* message,
 ProtobufCAllocator* allocator);
/* LogInformation methods */
void   log_information__init
(LogInformation*         message);
size_t log_information__get_packed_size
(const LogInformation*   message);
size_t log_information__pack
(const LogInformation*   message,
 uint8_t*             out);
size_t log_information__pack_to_buffer
(const LogInformation*   message,
 ProtobufCBuffer*     buffer);
LogInformation*
log_information__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   log_information__free_unpacked
(LogInformation* message,
 ProtobufCAllocator* allocator);
/* GetDeviceInformation methods */
void   get_device_information__init
(GetDeviceInformation*         message);
size_t get_device_information__get_packed_size
(const GetDeviceInformation*   message);
size_t get_device_information__pack
(const GetDeviceInformation*   message,
 uint8_t*             out);
size_t get_device_information__pack_to_buffer
(const GetDeviceInformation*   message,
 ProtobufCBuffer*     buffer);
GetDeviceInformation*
get_device_information__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   get_device_information__free_unpacked
(GetDeviceInformation* message,
 ProtobufCAllocator* allocator);
/* GetDeviceConfiguration methods */
void   get_device_configuration__init
(GetDeviceConfiguration*         message);
size_t get_device_configuration__get_packed_size
(const GetDeviceConfiguration*   message);
size_t get_device_configuration__pack
(const GetDeviceConfiguration*   message,
 uint8_t*             out);
size_t get_device_configuration__pack_to_buffer
(const GetDeviceConfiguration*   message,
 ProtobufCBuffer*     buffer);
GetDeviceConfiguration*
get_device_configuration__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   get_device_configuration__free_unpacked
(GetDeviceConfiguration* message,
 ProtobufCAllocator* allocator);
/* NotifyDeviceConfiguration methods */
void   notify_device_configuration__init
(NotifyDeviceConfiguration*         message);
size_t notify_device_configuration__get_packed_size
(const NotifyDeviceConfiguration*   message);
size_t notify_device_configuration__pack
(const NotifyDeviceConfiguration*   message,
 uint8_t*             out);
size_t notify_device_configuration__pack_to_buffer
(const NotifyDeviceConfiguration*   message,
 ProtobufCBuffer*     buffer);
NotifyDeviceConfiguration*
notify_device_configuration__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   notify_device_configuration__free_unpacked
(NotifyDeviceConfiguration* message,
 ProtobufCAllocator* allocator);
/* State methods */
void   state__init
(State*         message);
size_t state__get_packed_size
(const State*   message);
size_t state__pack
(const State*   message,
 uint8_t*             out);
size_t state__pack_to_buffer
(const State*   message,
 ProtobufCBuffer*     buffer);
State*
state__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   state__free_unpacked
(State* message,
 ProtobufCAllocator* allocator);
/* GetState methods */
void   get_state__init
(GetState*         message);
size_t get_state__get_packed_size
(const GetState*   message);
size_t get_state__pack
(const GetState*   message,
 uint8_t*             out);
size_t get_state__pack_to_buffer
(const GetState*   message,
 ProtobufCBuffer*     buffer);
GetState*
get_state__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   get_state__free_unpacked
(GetState* message,
 ProtobufCAllocator* allocator);
/* SetState methods */
void   set_state__init
(SetState*         message);
size_t set_state__get_packed_size
(const SetState*   message);
size_t set_state__pack
(const SetState*   message,
 uint8_t*             out);
size_t set_state__pack_to_buffer
(const SetState*   message,
 ProtobufCBuffer*     buffer);
SetState*
set_state__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   set_state__free_unpacked
(SetState* message,
 ProtobufCAllocator* allocator);
/* SynchronizeState methods */
void   synchronize_state__init
(SynchronizeState*         message);
size_t synchronize_state__get_packed_size
(const SynchronizeState*   message);
size_t synchronize_state__pack
(const SynchronizeState*   message,
 uint8_t*             out);
size_t synchronize_state__pack_to_buffer
(const SynchronizeState*   message,
 ProtobufCBuffer*     buffer);
SynchronizeState*
synchronize_state__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   synchronize_state__free_unpacked
(SynchronizeState* message,
 ProtobufCAllocator* allocator);
/* ForwardATCommand methods */
void   forward_atcommand__init
(ForwardATCommand*         message);
size_t forward_atcommand__get_packed_size
(const ForwardATCommand*   message);
size_t forward_atcommand__pack
(const ForwardATCommand*   message,
 uint8_t*             out);
size_t forward_atcommand__pack_to_buffer
(const ForwardATCommand*   message,
 ProtobufCBuffer*     buffer);
ForwardATCommand*
forward_atcommand__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   forward_atcommand__free_unpacked
(ForwardATCommand* message,
 ProtobufCAllocator* allocator);
/* ForwardTestCommand methods */
void   forward_test_command__init
(ForwardTestCommand*         message);
size_t forward_test_command__get_packed_size
(const ForwardTestCommand*   message);
size_t forward_test_command__pack
(const ForwardTestCommand*   message,
 uint8_t*             out);
size_t forward_test_command__pack_to_buffer
(const ForwardTestCommand*   message,
 ProtobufCBuffer*     buffer);
ForwardTestCommand*
forward_test_command__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   forward_test_command__free_unpacked
(ForwardTestCommand* message,
 ProtobufCAllocator* allocator);
/* IssueMediaControl methods */
void   issue_media_control__init
(IssueMediaControl*         message);
size_t issue_media_control__get_packed_size
(const IssueMediaControl*   message);
size_t issue_media_control__pack
(const IssueMediaControl*   message,
 uint8_t*             out);
size_t issue_media_control__pack_to_buffer
(const IssueMediaControl*   message,
 ProtobufCBuffer*     buffer);
IssueMediaControl*
issue_media_control__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data);
void   issue_media_control__free_unpacked
(IssueMediaControl* message,
 ProtobufCAllocator* allocator);
/* --- per-message closures --- */

typedef void (*ControlEnvelope_Closure)
(const ControlEnvelope* message,
 void* closure_data);
typedef void (*Response_Closure)
(const Response* message,
 void* closure_data);
typedef void (*Dialog_Closure)
(const Dialog* message,
 void* closure_data);
typedef void (*LocalAudioFile_Closure)
(const LocalAudioFile* message,
 void* closure_data);
typedef void (*SpeechInitiator__WakeWord_Closure)
(const SpeechInitiator__WakeWord* message,
 void* closure_data);
typedef void (*SpeechInitiator_Closure)
(const SpeechInitiator* message,
 void* closure_data);
typedef void (*SpeechSettings_Closure)
(const SpeechSettings* message,
 void* closure_data);
typedef void (*StartSpeech_Closure)
(const StartSpeech* message,
 void* closure_data);
typedef void (*CallingAsrProvideSpeech_Closure)
(const CallingAsrProvideSpeech* message,
 void* closure_data);
typedef void (*CallingAsrStopSpeech_Closure)
(const CallingAsrStopSpeech* message,
 void* closure_data);
typedef void (*ProvideSpeech_Closure)
(const ProvideSpeech* message,
 void* closure_data);
typedef void (*ProvideLocalAudioFile_Closure)
(const ProvideLocalAudioFile* message,
 void* closure_data);
typedef void (*SpeechProvider_Closure)
(const SpeechProvider* message,
 void* closure_data);
typedef void (*StopSpeech_Closure)
(const StopSpeech* message,
 void* closure_data);
typedef void (*EndPointSpeech_Closure)
(const EndPointSpeech* message,
 void* closure_data);
typedef void (*NotifySpeechState_Closure)
(const NotifySpeechState* message,
 void* closure_data);
typedef void (*DualProvideSpeech_Closure)
(const DualProvideSpeech* message,
 void* closure_data);
typedef void (*DeviceInformation_Closure)
(const DeviceInformation* message,
 void* closure_data);
typedef void (*PairInformation_Closure)
(const PairInformation* message,
 void* closure_data);
typedef void (*DeviceConfiguration_Closure)
(const DeviceConfiguration* message,
 void* closure_data);
typedef void (*GetLog_Closure)
(const GetLog* message,
 void* closure_data);
typedef void (*GetLogConfirm_Closure)
(const GetLogConfirm* message,
 void* closure_data);
typedef void (*LogInformation_Closure)
(const LogInformation* message,
 void* closure_data);
typedef void (*GetDeviceInformation_Closure)
(const GetDeviceInformation* message,
 void* closure_data);
typedef void (*GetDeviceConfiguration_Closure)
(const GetDeviceConfiguration* message,
 void* closure_data);
typedef void (*NotifyDeviceConfiguration_Closure)
(const NotifyDeviceConfiguration* message,
 void* closure_data);
typedef void (*State_Closure)
(const State* message,
 void* closure_data);
typedef void (*GetState_Closure)
(const GetState* message,
 void* closure_data);
typedef void (*SetState_Closure)
(const SetState* message,
 void* closure_data);
typedef void (*SynchronizeState_Closure)
(const SynchronizeState* message,
 void* closure_data);
typedef void (*ForwardATCommand_Closure)
(const ForwardATCommand* message,
 void* closure_data);
typedef void (*ForwardTestCommand_Closure)
(const ForwardTestCommand* message,
 void* closure_data);
typedef void (*IssueMediaControl_Closure)
(const IssueMediaControl* message,
 void* closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    transport__descriptor;
extern const ProtobufCEnumDescriptor    error_code__descriptor;
extern const ProtobufCEnumDescriptor    command__descriptor;
extern const ProtobufCEnumDescriptor    audio_source__descriptor;
extern const ProtobufCEnumDescriptor    audio_profile__descriptor;
extern const ProtobufCEnumDescriptor    audio_format__descriptor;
extern const ProtobufCEnumDescriptor    audio_scene__descriptor;
extern const ProtobufCEnumDescriptor    speech_state__descriptor;
extern const ProtobufCEnumDescriptor    initiator_type__descriptor;
extern const ProtobufCEnumDescriptor    sign_method__descriptor;
extern const ProtobufCEnumDescriptor    media_control__descriptor;
extern const ProtobufCMessageDescriptor control_envelope__descriptor;
extern const ProtobufCMessageDescriptor response__descriptor;
extern const ProtobufCMessageDescriptor dialog__descriptor;
extern const ProtobufCMessageDescriptor local_audio_file__descriptor;
extern const ProtobufCMessageDescriptor speech_initiator__descriptor;
extern const ProtobufCMessageDescriptor speech_initiator__wake_word__descriptor;
extern const ProtobufCEnumDescriptor    speech_initiator__type__descriptor;
extern const ProtobufCMessageDescriptor speech_settings__descriptor;
extern const ProtobufCMessageDescriptor start_speech__descriptor;
extern const ProtobufCMessageDescriptor calling_asr_provide_speech__descriptor;
extern const ProtobufCMessageDescriptor calling_asr_stop_speech__descriptor;
extern const ProtobufCMessageDescriptor provide_speech__descriptor;
extern const ProtobufCMessageDescriptor provide_local_audio_file__descriptor;
extern const ProtobufCMessageDescriptor speech_provider__descriptor;
extern const ProtobufCMessageDescriptor stop_speech__descriptor;
extern const ProtobufCMessageDescriptor end_point_speech__descriptor;
extern const ProtobufCMessageDescriptor notify_speech_state__descriptor;
extern const ProtobufCMessageDescriptor dual_provide_speech__descriptor;
extern const ProtobufCMessageDescriptor device_information__descriptor;
extern const ProtobufCMessageDescriptor pair_information__descriptor;
extern const ProtobufCMessageDescriptor device_configuration__descriptor;
extern const ProtobufCMessageDescriptor get_log__descriptor;
extern const ProtobufCMessageDescriptor get_log_confirm__descriptor;
extern const ProtobufCMessageDescriptor log_information__descriptor;
extern const ProtobufCMessageDescriptor get_device_information__descriptor;
extern const ProtobufCMessageDescriptor get_device_configuration__descriptor;
extern const ProtobufCMessageDescriptor notify_device_configuration__descriptor;
extern const ProtobufCMessageDescriptor state__descriptor;
extern const ProtobufCMessageDescriptor get_state__descriptor;
extern const ProtobufCMessageDescriptor set_state__descriptor;
extern const ProtobufCMessageDescriptor synchronize_state__descriptor;
extern const ProtobufCMessageDescriptor forward_atcommand__descriptor;
extern const ProtobufCMessageDescriptor forward_test_command__descriptor;
extern const ProtobufCMessageDescriptor issue_media_control__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_dma_2eproto__INCLUDED */
